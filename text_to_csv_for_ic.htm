<!DOCTYPE html>

<html>

<head>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="./css/normalize.css">

<link rel="stylesheet" href="./css/stylize.css">

<title>Text-to-CSV for IC</title>

</head>

<body>

<script src="./js/babel.js"></script>
<script src="./js/react.development.js"></script>
<script src="./js/react-dom.development.js"> </script>

  <h1>RTF-to-CSV for IC</h1>
    <h2><strong>How this works</strong></h2>

    1. Input the CSV template that the data is to be fit into, or leave it as the default as of 2023 (note: if you make changes, the header names must match the default).   
    <br><br>

    2. Select the <code>*.rtf</code> file(s) via "Browse..." that are to be fit into it.
    <br><br>

    3. The CSV will be automatically downloaded.

    <br><br>

    <strong>Privacy notice:</strong> all data processing is done solely on the computer running this <em>intentionally offline</em> website, via client-side Javascript engines available within any modern web browser.
    <br>No data is ever stored within the browser after exit (e.g. using localStorage), or transmitted over any network connection.
    <br>The offline nature can be verified by pressing F12, choosing "Network", and adjusting headers to show "URL", or by simply disconnecting the computer from internet/network.
    <br><br>

    <em>Javascript by Thomas. Framework by React.js v18.2.</em>
    <br><br><br>

    <div id="root"> </div>

    <script type="text/babel">
  
      const { useState, useEffect } = React;

      function csv_to_obj(csv_header) {

	  const obj_template = {};

	  csv_header.split(',').map(
	      
	      (field_name) => obj_template[field_name] = '' )

	  return obj_template;

      };

      function format_data(data_as_objs, csv_header) {

	  const csv_header_arr = csv_header.split(',');
	  
	  const final_output = new Array(data_as_objs.length + 1);

	  final_output[0] = csv_header;

	  data_as_objs.map( (obj, index_a) => {

	      const new_row = new Array(csv_header_arr.length);
	      
	      csv_header_arr.map( (header, index_b) => {

		  new_row[index_b] = obj[header];

	      })


	      final_output[index_a + 1] = new_row.join(',');

	  });

	  console.log(final_output);
	  
	  return final_output.join('\n');

      };

      function convert_rtf_to_plain_text(rtf) {
	  
	  return rtf
	      .replace(/\\par[d]?/g, '')
	      .replace(/\{\*?\\[^{}]+}|[{}]|\\\n?[A-Za-z]+\n?(?:-?\d+)?[ ]?/g, '').trim();

      };

      function add_data_to_objs(objs_arr) {

	  const date = new Date();

	  return objs_arr.map( function (obj) {

	      obj["DATE"] = date.toLocaleDateString('en-GB', {
		  year: 'numeric',
		  month: '2-digit',
		  day: '2-digit',
	      });

	      obj["REFERRAL TYPE"] = "Email";

	      obj["REFERRAL SOURCE"] = "UHL";

	  })

      }

      function extract_data_from_rtf(new_obj, text_data) {

	  //  this is where the application-specific knowledge is

	  // console.log('text-data', typeof text_data, text_data);

	  const names = text_data.match(/Name:.*Sex:/)[0]
		.replace('Name:','')
		.replace('Sex:', '')
		.split(',');

	  new_obj['NAME'] = names[1].trim();
	  
	  new_obj['SURNAME'] = names[0].trim();

	  new_obj['DOB'] = text_data.match(/DOB.*Age/)[0].match(/[0-9]{4}/)[0].trim();

	  const phones = text_data.match(/Telephone.*Hospital/)[0]
		.replace('Telephone:','')
		.replace('Hospital:','').trim();

	  new_obj['MOB'] = phones.match(/Mobile = [0-9]*/)[0]
	      .replace('Mobile = ','').trim();
	  
	  new_obj['TEL'] = phones.match(/Home = [0-9]*/)[0]
	      .replace('Home = ', '').trim();

	  const address = text_data.match(/Address.*Patient Telephone/)[0]
		.replace('Address:','')
		.replace('Patient Telephone','')
		.split(',');

	  new_obj['ADDRESS'] = address[0].trim();
	  
	  new_obj['POST CODE'] = address.slice(-1)[0].trim();

	  new_obj["REFERRER NAME"] = text_data
	      .match(/Requesting Doctor.*Consultant/)[0]
	      .replace('Requesting Doctor:', '')
	      .replace('Consultant', '')
	      .replace(', ','').trim();

	  new_obj["REFERRING DEPT/ORG"] = text_data
	      .match(/Referring Speciality.*Other/)[0]
	      .replace('Referring Speciality','')
	      .replace('Other','')
	      .replace(',','').trim();
	  
	  new_obj["PRACTICE"] = text_data
	      .match(/Practice.*_/)[0]
	      .replace('Practice:','')
	      .replace(/,.*/,'').trim();
	  
	  return new_obj;

      };

      function process_data(loaded_files, csv_header) {

	  // console.log('process data #1', loaded_files);
	  
	  const cleaned_data_arr = loaded_files.map( (data, index) => 
	      
	      convert_rtf_to_plain_text(data)

	  );

	  console.log(cleaned_data_arr);

	  const obj_template = csv_to_obj(csv_header);

	  const data_as_objs_arr = cleaned_data_arr.map( (data) => 

	      extract_data_from_rtf(obj_template, data)

	  );

	  console.log(data_as_objs_arr);

	  return data_as_objs_arr;

      };

      function files_load(preloaded_files, set_loaded_files){

	  let open_files = [];

	  if (preloaded_files.length) {
	      
	      const file_readers = preloaded_files.map((file, index) => {

		  const f_reader = new FileReader();
		  
		  //  .onload stores a function to be called when file read done
		  
		  f_reader.onload = (e) => {
		      
		      const { result } = e.target;
		      
		      if (result) {
			  
			  open_files = [ ...open_files, result ];

		      }

		      const all_files_read = file_readers.every( function (f_r) {

			  return f_r.readyState === 2;

		      });

		      if (all_files_read === true) {

			  set_loaded_files(open_files);
			  
		      }
		      
		  }

		  //  .readAsText() initiates a file reading
		  
		  f_reader.readAsText(file);

		  return f_reader;
		  
	      })

	  };

      }

      function download_data(formatted_data) {

	  console.log(formatted_data);

	  if (formatted_data.split('\n').length > 1) {

	      const file = new Blob([ formatted_data ], { type: 'text/csv' });

	      const element = document.createElement("a");

	      element.href = URL.createObjectURL(file);

	      const date = new Date();

	      const date_str = date.toLocaleDateString('ja-JP', {
		  year: 'numeric',
		  month: '2-digit',
		  day: '2-digit',
	      })

	      element.download = 'ic_data_' + date_str.replace('/','_') + '_'
		  + String(date.getHours()).padStart(2, '0')
		  + String(date.getMinutes()).padStart(2, '0')
		  +'.csv';

	      document.body.appendChild(element);

	      element.click();

	  }
	  
      }
      
      function File_upload({ preloaded_files, store_preloaded_files, set_loaded_files }) {

	  //  https://blog.logrocket.com/using-filereader-api-preview-images-react/

	  function handle_change(event) {
	      
	      files_load(Array.from(event.target.files), set_loaded_files);
	      
	  };

	  return(
		  <div>
		  <input type="file" accept=".rtf" onChange={(event) => handle_change(event)} multiple/> 
		  </div>
	  )
	  
      };

      const App = function Main() {

	  const [csv_header, set_csv_header] = useState(
              'DATE,NAME,SURNAME,ADDRESS,POST CODE,TEL,MOB,EMAIL,DOB,REFERRAL TYPE,REFERRAL SOURCE,REFERRING DEPT/ORG,REFERRER NAME,PRACTICE');

	  const [loaded_files, set_loaded_files] = useState([]);

	  const [formatted_data, set_formatted_data] = useState("");
	  
	  useEffect(() => {

	      console.log("loaded_files changed", loaded_files);

	      const data_as_objs_arr = process_data(loaded_files, csv_header);

	      const data_as_objs_arr_extra = add_data_to_objs(data_as_objs_arr);

	      set_formatted_data(format_data(data_as_objs_arr, csv_header));

	  }, [loaded_files, csv_header]);

	  useEffect(() => {

	      download_data(formatted_data);

	  }, [formatted_data]);

	  // useEffect(() => {

	  // 	  console.log("useEffect #2", processed_data);

	  // download_data(processed_data, csv_header);

	  // }, [processed_data]);

	  return (
		  <>

	      CSV header: <br/>
		  <textarea className='short' name='csv_header' defaultValue={csv_header} onChange={event => set_csv_header(event.target.value)} ></textarea>
		  <br/>

		  <File_upload set_loaded_files={set_loaded_files} />
		  <br/>

	      Data processed to CSV (automatically downloaded): <br/>
		  <textarea className='long' name='csv_output' value={formatted_data} readOnly ></textarea>

	      </>
	  )

      };
      
      const root = ReactDOM.createRoot(document.getElementById('root'));
      
      root.render(
	      <App />
      );


</script>
  
  
</body>

</html>
